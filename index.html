<!doctype html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>IB → Податки Україна (ПДФО + ВЗ) — v3.3 (FIFO + НБУ)</title>
  <style>
    :root {
      --bg: #0b0f17;
      --card: #121a27;
      --muted: #93a4c7;
      --text: #e8eefc;
      --good: #2ee59d;
      --bad: #ff6b6b;
      --warn: #ffd166;
      --line: rgba(255,255,255,0.08);
      --btn: #2d6cdf;
      --btn2: #2a3347;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif;
    }
    html, body { background: var(--bg); color: var(--text); font-family: var(--sans); margin: 0; }
    a { color: #9dc1ff; }
    header { padding: 18px 16px 0; max-width: 1120px; margin: 0 auto; }
    header h1 { font-size: 18px; margin: 0 0 8px 0; }
    header p { margin: 0 0 12px 0; color: var(--muted); line-height: 1.4; }
    main { padding: 10px 16px 32px; max-width: 1120px; margin: 0 auto; }
    .grid { display: grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 980px) { .grid { grid-template-columns: 1fr 1fr; } }
    .card {
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 14px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.25);
    }
    .card h2 { font-size: 14px; margin: 0 0 10px 0; }
    .card h3 { font-size: 13px; margin: 14px 0 8px 0; }
    .muted { color: var(--muted); }
    .small { font-size: 12px; }
    .row { display: grid; grid-template-columns: 1fr; gap: 10px; }
    @media (min-width: 720px) { .row { grid-template-columns: 1fr 1fr; } }
    .field { display: grid; gap: 6px; }
    .field label { font-size: 12px; color: var(--muted); }
    input[type="file"], input[type="number"], input[type="text"], select, textarea {
      background: rgba(255,255,255,0.04);
      color: var(--text);
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 10px 10px;
      outline: none;
    }
    textarea { min-height: 90px; resize: vertical; font-family: var(--mono); font-size: 12px; }
    .btns { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 10px; }
    button {
      border: 0;
      border-radius: 10px;
      padding: 10px 12px;
      background: var(--btn);
      color: white;
      cursor: pointer;
      font-weight: 700;
    }
    button.secondary { background: var(--btn2); }
    button:disabled { opacity: 0.55; cursor: not-allowed; }
    .hr { height: 1px; background: var(--line); margin: 12px 0; }
    details { border: 1px solid var(--line); border-radius: 10px; padding: 10px; }
    details summary { cursor: pointer; color: #cfe0ff; font-weight: 700; }
    .status {
      margin-top: 10px;
      padding: 10px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,0.03);
      font-size: 12px;
      line-height: 1.35;
      white-space: pre-wrap;
    }
    .status.good { border-color: rgba(46,229,157,0.35); }
    .status.bad { border-color: rgba(255,107,107,0.35); }
    .status.warn { border-color: rgba(255,209,102,0.35); }
    .tag {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--line);
      font-size: 11px;
      color: var(--muted);
      margin-left: 6px;
      background: rgba(255,255,255,0.02);
    }
    .kpi { display: grid; grid-template-columns: 1fr; gap: 8px; }
    @media (min-width: 720px) { .kpi { grid-template-columns: 1fr 1fr; } }
    .kpi .box {
      border: 1px solid var(--line);
      background: rgba(255,255,255,0.02);
      border-radius: 12px;
      padding: 10px;
    }
    .kpi .box .t { font-size: 12px; color: var(--muted); }
    .kpi .box .v { font-size: 16px; font-weight: 900; margin-top: 6px; font-family: var(--mono); }
    table { width: 100%; border-collapse: collapse; margin-top: 8px; overflow: hidden; border-radius: 10px; }
    th, td { border-bottom: 1px solid var(--line); padding: 8px 8px; vertical-align: top; font-size: 12px; }
    th { text-align: left; color: #cfe0ff; background: rgba(255,255,255,0.03); position: sticky; top: 0; }
    td.num { text-align: right; font-variant-numeric: tabular-nums; font-family: var(--mono); white-space: nowrap; }
    .tableWrap { max-height: 340px; overflow: auto; border: 1px solid var(--line); border-radius: 10px; }
    .mono { font-family: var(--mono); font-variant-numeric: tabular-nums; }
  </style>
</head>

<body>
<header>
  <h1>IB → Податки Україна (ПДФО + військовий збір) — v3.3 <span class="tag">FIFO + НБУ</span></h1>
  <p>
    Локальний HTML‑калькулятор: завантажуєш CSV з IB → завантажуєш/скачуєш курси НБУ → отримуєш розрахунок ПДФО/ВЗ,
    таблицю Ф1 та експорт (CSV/XLSX/друк). <span class="tag">⚠️ не є податковою консультацією</span>
  </p>
</header>

<main>
  <div class="grid">
    <!-- КРОК 1 -->
    <section class="card" id="step1">
      <h2>1) Завантаження звіту IB та курсів НБУ</h2>

      <div class="field">
        <label>Завантажте CSV‑звіт IB (Flex/Activity, multi‑section)</label>
        <input id="fileCsv" type="file" accept=".csv,text/csv" />
      </div>

      <div class="btns">
        <button id="btnParse" disabled>Розпізнати звіт</button>
        <button id="btnReset" class="secondary" disabled>Скинути</button>
      </div>

      <div id="statusUpload" class="status">Очікую CSV…</div>

      <div class="hr"></div>

      <h3>Курси НБУ для перерахунку у гривню</h3>
      <div class="small muted">
        Рекомендований порядок: ① завантажити CSV → ② якщо у вас уже є JSON‑курси — натисніть “Підвантаж JSON‑файли”.
        Якщо JSON немає — натисніть “Завантажити курси НБУ (і застосувати)”. Якщо онлайн‑завантаження не працює —
        “Показати посилання НБУ (fallback)”.
      </div>

      <div class="row" style="margin-top:10px;">
        <div class="field">
          <label>JSON‑файли курсів (підтримка: fx_bundle.json або USD.json/EUR.json з НБУ)</label>
          <input id="fxFiles" type="file" accept="application/json,.json" multiple />
        </div>
        <div class="field">
          <label>Статус курсів</label>
          <div id="fxStatus" class="status">Спочатку розпізнайте CSV, щоб визначити потрібні валюти та дати.</div>
        </div>
      </div>

      <div class="btns">
        <!-- ПЕРША -->
        <button id="btnLoadFxFiles" class="secondary">Підвантаж JSON‑файли</button>

        <!-- ОСНОВНА "ЗА ЗАМОВЧУВАННЯМ" -->
        <button id="btnDownloadFx" disabled>Завантажити курси НБУ (і застосувати)</button>

        <button id="btnShowFxLinks" class="secondary" disabled>Показати посилання НБУ (fallback)</button>
        <button id="btnDownloadFxLinksFile" class="secondary" disabled>Завантажити файл з посиланнями</button>
        <button id="btnClearFx" class="secondary" disabled>Очистити курси</button>
      </div>

      <div id="fxLinksBox" class="status" style="display:none;"></div>

      <details style="margin-top:10px;">
        <summary>Чому “Завантажити курси НБУ” інколи не працює?</summary>
        <div class="small muted" style="margin-top:8px; line-height:1.5;">
          <ul>
            <li>Браузер може блокувати запити до API НБУ, особливо якщо HTML відкрито як <span class="mono">file://</span> (origin null) або мережа обмежена.</li>
            <li>Fallback завжди працює: <b>“Показати посилання НБУ”</b> → відкрити → зберегти JSON → <b>“Підвантаж JSON‑файли”</b>.</li>
            <li>Ще варіант: відкрити HTML через локальний сервер: <span class="mono">python -m http.server 8000</span> і перейти на <span class="mono">http://localhost:8000/ib_ua_tax_v3_3.html</span>.</li>
          </ul>
        </div>
      </details>
    </section>

    <!-- КРОК 2 -->
    <section class="card" id="step2">
      <h2>2) Налаштування розрахунку</h2>

      <div class="row">
        <div class="field">
          <label>Податковий рік</label>
          <select id="taxYear">
            <option value="2025" selected>2025</option>
            <option value="2024">2024</option>
          </select>
        </div>
        <div class="field">
          <label>Метод обліку</label>
          <select id="lotMethod">
            <option value="FIFO" selected>FIFO</option>
          </select>
        </div>
      </div>

      <div class="hr"></div>

      <h3>Ставки</h3>
      <div class="row">
        <div class="field">
          <label>ПДФО на інвестприбуток (наприклад, 0.18)</label>
          <input id="pitInvestRate" type="number" step="0.01" value="0.18" />
        </div>
        <div class="field">
          <label>Військовий збір на інвестприбуток (наприклад, 0.05)</label>
          <input id="milInvestRate" type="number" step="0.01" value="0.05" />
        </div>
      </div>

      <div class="row">
        <div class="field">
          <label>ПДФО на дивіденди нерезидента (наприклад, 0.09)</label>
          <input id="pitDivRate" type="number" step="0.01" value="0.09" />
        </div>
        <div class="field">
          <label>Військовий збір на дивіденди (наприклад, 0.05)</label>
          <input id="milDivRate" type="number" step="0.01" value="0.05" />
        </div>
      </div>

      <div class="row">
        <div class="field">
          <label>Перенесений інвестзбиток минулих років (грн)</label>
          <input id="carryLossUAH" type="number" step="0.01" value="0" />
        </div>
        <div class="field">
          <label>Код виду інвестактиву для Ф1</label>
          <select id="f1AssetTypeMode">
            <option value="ALL_4" selected>За замовчуванням: усе = 4 (іноземні джерела)</option>
            <option value="MANUAL">Ручна мапа (JSON нижче)</option>
          </select>
        </div>
      </div>

      <div class="field" id="manualMapWrap" style="display:none;">
        <label>Ручна мапа кодів Ф1 (JSON: {"ASSETKEY":4, ...})</label>
        <textarea id="f1ManualMap" spellcheck="false">{}</textarea>
      </div>

      <div class="hr"></div>

      <div class="field">
        <label>
          <input id="useForeignTaxCredit" type="checkbox" />
          Враховувати залік іноземного податку за дивідендами (зменшує ПДФО, НЕ зменшує ВЗ)
        </label>
      </div>

      <div class="field">
        <label>
          <input id="treatPILasDividend" type="checkbox" checked />
          “Payment in Lieu of Dividend” вважати дивідендами
        </label>
      </div>

      <div class="btns">
        <button id="btnCalc" disabled>Розрахувати податки + сформувати Ф1</button>
      </div>

      <div id="statusCalc" class="status">Спочатку розпізнайте CSV та підготуйте курси НБУ.</div>
    </section>
  </div>

  <!-- КРОК 3 -->
  <section class="card" id="step3">
    <h2>3) Попередній перегляд розпізнаних даних</h2>

    <div class="kpi">
      <div class="box"><div class="t">Діапазон дат у файлі</div><div class="v" id="kpiDates">—</div></div>
      <div class="box"><div class="t">Валюти у файлі</div><div class="v" id="kpiCurrencies">—</div></div>
      <div class="box"><div class="t">Угоди (Trades)</div><div class="v" id="kpiTrades">—</div></div>
      <div class="box"><div class="t">Дивіденди / Утримання / Відкриті позиції</div><div class="v" id="kpiOther">—</div></div>
    </div>

    <div class="hr"></div>

    <div id="warningsBox" class="status warn" style="display:none;"></div>

    <details>
      <summary>Прев’ю угод (Trades) — перші 200</summary>
      <div class="tableWrap"><table id="tblTrades"></table></div>
    </details>

    <details style="margin-top:10px;">
      <summary>Прев’ю дивідендів — перші 200</summary>
      <div class="tableWrap"><table id="tblDiv"></table></div>
    </details>

    <details style="margin-top:10px;">
      <summary>Прев’ю утримань податку (Withholding Tax) — перші 200</summary>
      <div class="tableWrap"><table id="tblWh"></table></div>
    </details>

    <details style="margin-top:10px;">
      <summary>Прев’ю відкритих позицій — перші 200</summary>
      <div class="tableWrap"><table id="tblPos"></table></div>
    </details>

    <div class="btns">
      <button id="btnDownloadParsed" class="secondary" disabled>Завантажити розпізнаний Statement (JSON)</button>
    </div>
  </section>

  <!-- КРОК 4 -->
  <section class="card" id="step4">
    <h2>4) Результати розрахунку (грн)</h2>

    <div id="resultsBox" class="status">Поки що немає розрахунку.</div>

    <details style="margin-top:10px;">
      <summary>Таблиця Ф1 (агрегація за активами)</summary>
      <div class="tableWrap"><table id="tblF1"></table></div>
    </details>

    <details style="margin-top:10px;">
      <summary>Операції (FIFO‑зіставлення) — показано перші 300</summary>
      <div class="tableWrap"><table id="tblOps"></table></div>
    </details>

    <div class="btns">
      <button id="btnExportXlsx" disabled>Завантажити XLSX (Підсумок + Декларація + Ф1 + Операції)</button>
      <button id="btnExportCsv" class="secondary" disabled>Завантажити CSV (Ф1 + Операції)</button>
      <button id="btnPrintF1" class="secondary" disabled>Відкрити друковану форму Ф1</button>
      <button id="btnDownloadDebug" class="secondary" disabled>Завантажити DEBUG (JSON)</button>
    </div>

    <div class="small muted" style="margin-top:8px;">
      XLSX‑експорт використовує SheetJS через CDN (якщо інтернет недоступний — користуйтеся CSV або друком).
    </div>
  </section>

  <!-- КРОК 5 -->
  <section class="card" id="step5">
    <h2>5) Відкриті позиції: де зараз найбільші збитки (за звітом)</h2>
    <div class="small muted">
      Підказка: які позиції зараз у найбільшому мінусі у гривні (за Unrealized P/L зі звіту IB та курсом НБУ). Це не інвестпорада.
    </div>

    <div class="row" style="margin-top:10px;">
      <div class="field">
        <label>Дата FX для конвертації (за замовчуванням = кінець періоду звіту)</label>
        <input id="asOfDate" type="text" placeholder="YYYY-MM-DD" />
        <div class="small muted">Unrealized P/L береться зі звіту; змінюючи дату, ви змінюєте лише FX‑курс.</div>
      </div>
      <div class="field">
        <label>Показати топ N збиткових позицій</label>
        <input id="topN" type="number" step="1" value="15" />
      </div>
    </div>

    <div class="btns">
      <button id="btnShowLosers" disabled>Показати</button>
    </div>

    <div id="losersBox" class="status">Поки що немає даних.</div>
  </section>
</main>

<script>
/* =========================
   UI helpers
========================= */
const $ = (sel) => document.querySelector(sel);

function escapeHtml(s) {
  return String(s ?? "")
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#039;");
}
function setStatus(el, msg, kind="") {
  el.textContent = msg;
  el.classList.remove("good","bad","warn");
  if (kind) el.classList.add(kind);
}

/**
 * Формат: 1'000.00 (2 знаки, розділювач тисяч — апостроф)
 */
function fmt2(x) {
  if (!Number.isFinite(x)) return "—";
  const neg = x < 0;
  const v = Math.abs(x);
  const s = (Math.round((v + Number.EPSILON) * 100) / 100).toFixed(2);
  let [intPart, decPart] = s.split(".");
  intPart = intPart.replace(/\B(?=(\d{3})+(?!\d))/g, "'");
  return (neg ? "-" : "") + intPart + "." + decPart;
}
function round2(x) { return Math.round((x + Number.EPSILON) * 100) / 100; }

function downloadBlob(filename, mime, textOrBlob) {
  const blob = textOrBlob instanceof Blob ? textOrBlob : new Blob([textOrBlob], { type: mime });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}
function toCsv(rows) {
  const esc = (v) => {
    const s = String(v ?? "");
    if (/[",\n\r]/.test(s)) return '"' + s.replaceAll('"','""') + '"';
    return s;
  };
  return rows.map(r => r.map(esc).join(",")).join("\n");
}

/* =========================
   CSV parsing
========================= */
function stripBom(s) {
  return s && s.charCodeAt(0) === 0xFEFF ? s.slice(1) : s;
}
function parseNumber(s) {
  if (s === null || s === undefined) return null;
  let x = String(s).trim();
  if (!x) return null;
  const m = x.match(/^\((.*)\)$/);
  if (m) x = "-" + m[1];
  x = x.replaceAll(",", "");
  const v = Number(x);
  return Number.isFinite(v) ? v : null;
}
function parseCSV(text) {
  text = stripBom(text);
  const rows = [];
  let row = [];
  let field = "";
  let i = 0;
  let inQuotes = false;

  while (i < text.length) {
    const c = text[i];
    if (inQuotes) {
      if (c === '"') {
        if (text[i+1] === '"') { field += '"'; i += 2; continue; }
        inQuotes = false; i++; continue;
      }
      field += c; i++; continue;
    } else {
      if (c === '"') { inQuotes = true; i++; continue; }
      if (c === ",") { row.push(field); field = ""; i++; continue; }
      if (c === "\r") { i++; continue; }
      if (c === "\n") { row.push(field); rows.push(row); row = []; field = ""; i++; continue; }
      field += c; i++; continue;
    }
  }
  if (field.length > 0 || row.length > 0) { row.push(field); rows.push(row); }
  return rows;
}
function rowToObject(header, data) {
  const obj = {};
  for (let i = 0; i < header.length; i++) {
    const k = header[i];
    if (!k) continue;
    obj[k] = data[i] ?? "";
  }
  return obj;
}

/* =========================
   Dates
========================= */
const EN_MONTH = {
  january: 1, february: 2, march: 3, april: 4, may: 5, june: 6,
  july: 7, august: 8, september: 9, october: 10, november: 11, december: 12,
};
function pad2(n){ return n < 10 ? "0"+n : String(n); }
function parseEnglishDate(s) {
  const t = String(s).trim();
  const m = t.match(/^([A-Za-z]+)\s+(\d{1,2}),\s*(\d{4})$/);
  if (!m) return null;
  const mon = EN_MONTH[m[1].toLowerCase()];
  if (!mon) return null;
  const day = Number(m[2]);
  const year = Number(m[3]);
  if (!(day>=1 && day<=31)) return null;
  return `${year}-${pad2(mon)}-${pad2(day)}`;
}
function parsePeriodRange(s) {
  const t = String(s).trim();
  const parts = t.split(" - ");
  if (parts.length !== 2) return null;
  const a = parseEnglishDate(parts[0]);
  const b = parseEnglishDate(parts[1]);
  if (!a || !b) return null;
  return { start: a, end: b };
}
function parseIBDateTime(s) {
  const t = String(s).trim();
  const parts = t.split(",").map(x => x.trim());
  const date = parts[0];
  const time = parts[1] ? parts[1] : "00:00:00";
  return { iso: `${date}T${time}`, tradeDate: date };
}
function minIso(a, b) {
  if (!a) return b;
  if (!b) return a;
  return a < b ? a : b;
}
function maxIso(a, b) {
  if (!a) return b;
  if (!b) return a;
  return a > b ? a : b;
}

/* =========================
   Options parser + assetKey
========================= */
const MONTHS = { JAN:1,FEB:2,MAR:3,APR:4,MAY:5,JUN:6,JUL:7,AUG:8,SEP:9,OCT:10,NOV:11,DEC:12 };
function parseIbExpiryToken(token) {
  const t = String(token || "").trim().toUpperCase();
  const m = t.match(/^(\d{1,2})([A-Z]{3})(\d{2})$/);
  if (!m) return null;
  const day = Number(m[1]);
  const mon = MONTHS[m[2]];
  const yy = Number(m[3]);
  if (!mon || day<1 || day>31) return null;
  const year = yy <= 69 ? 2000 + yy : 1900 + yy;
  return `${year}-${pad2(mon)}-${pad2(day)}`;
}
function parseIbOptionSymbol(symbolRaw) {
  const s = String(symbolRaw || "").trim().replace(/\s+/g, " ");
  const parts = s.split(" ");
  if (parts.length < 4) return null;
  const rightToken = parts[parts.length-1].toUpperCase();
  const strikeToken = parts[parts.length-2];
  const expiryToken = parts[parts.length-3];
  if (rightToken !== "C" && rightToken !== "P") return null;
  const expiry = parseIbExpiryToken(expiryToken);
  if (!expiry) return null;
  const strike = Number(strikeToken);
  if (!Number.isFinite(strike)) return null;
  const underlying = parts.slice(0, parts.length-3).join(" ");
  if (!underlying) return null;
  return { kind:"OPTION", underlying, expiry, strike, right:rightToken, multiplier:100 };
}
function makeAssetKey(assetCategory, currency, symbolRaw) {
  const opt = parseIbOptionSymbol(symbolRaw);
  if (opt) {
    return {
      assetKey: `OPT|${currency}|${opt.underlying}|${opt.expiry}|${opt.strike}|${opt.right}`,
      instrument: opt,
      kind: "OPTION"
    };
  }
  const sym = String(symbolRaw || "").trim().replace(/\s+/g, "");
  return { assetKey: `STK|${currency}|${sym}`, instrument: { kind:"STOCK" }, kind:"STOCK" };
}
function extractSymbolIsinFromDescription(desc) {
  const s = String(desc || "").trim();
  const m = s.match(/^([A-Z0-9.\-]+)\(([A-Z]{2}[A-Z0-9]{10})\)/);
  if (!m) return null;
  return { symbol: m[1], isin: m[2] };
}

/* =========================
   Statement parser
========================= */
function emptyStatement(fileName) {
  return {
    meta: {
      provider: "IB_FLEX_CSV",
      fileName,
      brokerName: null,
      brokerAddress: null,
      title: null,
      periodStart: null,
      periodEnd: null,
      generatedAt: null,
      asOfDate: null,
    },
    accounts: [],
    trades: [],
    cashIncomes: [],
    withholdings: [],
    positions: [],
    warnings: [],
  };
}
function warn(st, code, message, extra={}) {
  st.warnings.push({ code, message, ...extra });
}
function parseFlexReport(rows, fileName) {
  const st = emptyStatement(fileName);
  const headers = new Map();
  const seenStatementFields = new Set();

  for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
    const row = rows[rowIndex];
    if (!row || row.length < 2) continue;

    const section = stripBom(String(row[0] || "")).trim();
    const type = String(row[1] || "").trim();
    const rest = row.slice(2);

    if (type === "Header") {
      headers.set(section, rest);
      continue;
    }
    if (type !== "Data") continue;

    const header = headers.get(section);
    if (!header) continue;
    const obj = rowToObject(header, rest);

    if (section === "Statement") {
      const fn = String(obj["Field Name"] || "").trim();
      const fv = String(obj["Field Value"] || "").trim();
      if (!fn) continue;

      if (seenStatementFields.has(fn)) continue;
      seenStatementFields.add(fn);

      if (fn === "BrokerName") st.meta.brokerName = fv;
      if (fn === "BrokerAddress") st.meta.brokerAddress = fv;
      if (fn === "Title") st.meta.title = fv;
      if (fn === "Period") {
        const pr = parsePeriodRange(fv);
        if (pr) {
          st.meta.periodStart = pr.start;
          st.meta.periodEnd = pr.end;
          st.meta.asOfDate = pr.end;
        } else {
          warn(st, "UNPARSEABLE_META", `Не вдалося розпізнати Period: ${fv}`, { section, row: rowIndex+1 });
        }
      }
      if (fn === "WhenGenerated") st.meta.generatedAt = fv;
      continue;
    }

    if (section === "Account Summary") {
      const account = String(obj["Account"] || "").trim();
      if (!account || account.toLowerCase() === "total") continue;
      st.accounts.push({
        currency: String(obj["Currency"] || "").trim(),
        accountId: account,
        alias: String(obj["Account Alias"] || "").trim(),
        name: String(obj["Name"] || "").trim(),
        priorNAV: parseNumber(obj["Prior NAV"]),
        currentNAV: parseNumber(obj["Current NAV"]),
        twr: String(obj["TWR"] || "").trim(),
      });
      continue;
    }

    if (section === "Trades") {
      const assetCategory = String(obj["Asset Category"] || "").trim();
      const currency = String(obj["Currency"] || "").trim();
      const symbolRaw = String(obj["Symbol"] || "").trim();
      const dtRaw = String(obj["Date/Time"] || "").trim();

      const qty = parseNumber(obj["Quantity"]);
      const tPrice = parseNumber(obj["T. Price"]);
      const proceeds = parseNumber(obj["Proceeds"]);
      const comm = parseNumber(obj["Comm/Fee"]) ?? 0;

      if (!currency || !symbolRaw || !dtRaw || qty === null || proceeds === null) continue;

      const { iso, tradeDate } = parseIBDateTime(dtRaw);
      const ak = makeAssetKey(assetCategory, currency, symbolRaw);

      // netCash: для IB proceeds знаковий: BUY зазвичай від’ємний, SELL додатний; комісія зазвичай від’ємна
      const netCash = (proceeds ?? 0) + (comm ?? 0);

      st.trades.push({
        id: `${fileName}:Trades:${rowIndex+1}`,
        asset: { assetCategory, currency, symbolRaw, instrument: ak.instrument, assetKey: ak.assetKey, kind: ak.kind },
        dateTime: iso,
        tradeDate,
        quantity: qty,
        tradePrice: tPrice,
        proceeds,
        commission: comm,
        netCash,
      });
      continue;
    }

    if (section === "Dividends") {
      const currency = String(obj["Currency"] || "").trim();
      const date = String(obj["Date"] || "").trim();
      const desc = String(obj["Description"] || "").trim();
      const amount = parseNumber(obj["Amount"]);
      if (!currency || !date || amount === null) continue;

      let kind = "OTHER";
      const dlow = desc.toLowerCase();
      if (dlow.includes("payment in lieu")) kind = "PIL_DIVIDEND";
      else if (dlow.includes("cash dividend")) kind = "DIVIDEND";

      const si = extractSymbolIsinFromDescription(desc);

      st.cashIncomes.push({
        id: `${fileName}:Dividends:${rowIndex+1}`,
        kind, currency, date, amount,
        description: desc,
        symbolHint: si ? si.symbol : null,
        isinHint: si ? si.isin : null,
      });
      continue;
    }

    if (section === "Withholding Tax") {
      const currency = String(obj["Currency"] || "").trim();
      const date = String(obj["Date"] || "").trim();
      const desc = String(obj["Description"] || "").trim();
      const amount = parseNumber(obj["Amount"]);
      if (!currency || !date || amount === null) continue;

      const si = extractSymbolIsinFromDescription(desc);

      st.withholdings.push({
        id: `${fileName}:Withholding:${rowIndex+1}`,
        currency, date, amount,
        description: desc,
        symbolHint: si ? si.symbol : null,
        isinHint: si ? si.isin : null,
      });
      continue;
    }

    if (section === "Open Positions") {
      const assetCategory = String(obj["Asset Category"] || "").trim();
      const currency = String(obj["Currency"] || "").trim();
      const symbolRaw = String(obj["Symbol"] || "").trim();
      const qty = parseNumber(obj["Quantity"]);
      const costBasis = parseNumber(obj["Cost Basis"]);
      const value = parseNumber(obj["Value"]);
      const upl = parseNumber(obj["Unrealized P/L"]);
      if (!currency || !symbolRaw || qty === null || costBasis === null || value === null || upl === null) continue;

      const ak = makeAssetKey(assetCategory, currency, symbolRaw);

      st.positions.push({
        id: `${fileName}:OpenPositions:${rowIndex+1}`,
        asset: { assetCategory, currency, symbolRaw, instrument: ak.instrument, assetKey: ak.assetKey, kind: ak.kind },
        quantity: qty,
        costBasis,
        value,
        unrealizedPL: upl,
      });
      continue;
    }
  }

  // fallback: період з назви файлу
  if (!st.meta.periodStart || !st.meta.periodEnd) {
    const m = String(fileName).match(/_(\d{8})_(\d{8})/);
    if (m) {
      const a = `${m[1].slice(0,4)}-${m[1].slice(4,6)}-${m[1].slice(6,8)}`;
      const b = `${m[2].slice(0,4)}-${m[2].slice(4,6)}-${m[2].slice(6,8)}`;
      st.meta.periodStart = a;
      st.meta.periodEnd = b;
      st.meta.asOfDate = b;
      warn(st, "META_FROM_FILENAME", `Період взято з назви файлу: ${a} — ${b}`);
    }
  }

  // попередження для FIFO: перша угода по активу — SELL
  const byAsset = new Map();
  const sorted = st.trades.slice().sort((a,b)=>a.dateTime.localeCompare(b.dateTime));
  for (const t of sorted) {
    if (!byAsset.has(t.asset.assetKey)) byAsset.set(t.asset.assetKey, []);
    byAsset.get(t.asset.assetKey).push(t);
  }
  for (const [assetKey, arr] of byAsset.entries()) {
    const first = arr[0];
    if (first && first.quantity < 0) {
      warn(st, "INSUFFICIENT_HISTORY_FOR_FIFO",
        `Актив ${assetKey}: перша угода у файлі — SELL. Якщо це не шорт, для коректного FIFO потрібна більш рання історія.`,
        { assetKey }
      );
    }
  }

  return st;
}

/* =========================
   Asset index for F1 names
========================= */
function buildAssetIndex(statement) {
  const index = new Map();
  const upsert = (m) => {
    const cur = index.get(m.assetKey);
    index.set(m.assetKey, cur ? ({...cur, ...m}) : ({...m}));
  };

  for (const t of statement.trades) {
    const k = t.asset.assetKey;
    const ccy = t.asset.currency;
    if (t.asset.instrument && t.asset.instrument.kind === "OPTION") {
      const o = t.asset.instrument;
      upsert({ assetKey:k, kind:"OPTION", currency:ccy, underlying:o.underlying, expiry:o.expiry, strike:o.strike, right:o.right, multiplier:o.multiplier });
    } else {
      const sym = k.split("|")[2] ?? t.asset.symbolRaw;
      upsert({ assetKey:k, kind:"STOCK", currency:ccy, symbol:sym });
    }
  }

  for (const p of statement.positions) {
    const k = p.asset.assetKey;
    const ccy = p.asset.currency;
    if (p.asset.instrument && p.asset.instrument.kind === "OPTION") {
      const o = p.asset.instrument;
      upsert({ assetKey:k, kind:"OPTION", currency:ccy, underlying:o.underlying, expiry:o.expiry, strike:o.strike, right:o.right, multiplier:o.multiplier });
    } else {
      const sym = k.split("|")[2] ?? p.asset.symbolRaw;
      upsert({ assetKey:k, kind:"STOCK", currency:ccy, symbol:sym });
    }
  }

  for (const ci of statement.cashIncomes) {
    const si = extractSymbolIsinFromDescription(ci.description);
    if (!si) continue;
    const assetKey = `STK|${ci.currency}|${si.symbol}`;
    upsert({ assetKey, kind:"STOCK", currency:ci.currency, symbol:si.symbol, isin:si.isin });
  }
  for (const w of statement.withholdings) {
    const si = extractSymbolIsinFromDescription(w.description);
    if (!si) continue;
    const assetKey = `STK|${w.currency}|${si.symbol}`;
    upsert({ assetKey, kind:"STOCK", currency:w.currency, symbol:si.symbol, isin:si.isin });
  }

  return index;
}
function humanNameFromAssetKey(assetIndex, assetKey) {
  const m = assetIndex.get(assetKey);
  if (!m) return assetKey;
  if (m.kind === "STOCK") {
    const isinPart = m.isin ? ` (ISIN ${m.isin})` : "";
    return `Акції/ETF: ${m.symbol ?? assetKey}${isinPart}, ${m.currency}`;
  }
  if (m.kind === "OPTION") {
    const cp = m.right === "C" ? "Call" : "Put";
    const mult = m.multiplier ? `, ×${m.multiplier}` : "";
    return `Опціон ${cp} на ${m.underlying}, exp ${m.expiry}, strike ${m.strike}${mult}, ${m.currency}`;
  }
  return assetKey;
}

/* =========================
   NBU FX URLs + parsing
========================= */
function isoToYyyymmdd(iso) { return String(iso).replaceAll("-", ""); }
function ddmmyyyy_to_iso(s) {
  const t = String(s || "").trim();
  const m = t.match(/^(\d{2})\.(\d{2})\.(\d{4})$/);
  if (!m) return null;
  return `${m[3]}-${m[2]}-${m[1]}`;
}
function buildNbuRangeUrl(ccy, startIso, endIso) {
  const start = isoToYyyymmdd(startIso);
  const end = isoToYyyymmdd(endIso);
  return `https://bank.gov.ua/NBU_Exchange/exchange_site?start=${start}&end=${end}&valcode=${encodeURIComponent(String(ccy).toLowerCase())}&sort=exchangedate&order=desc&json=`;
}

/* =========================
   FX store + loading
========================= */
const fxStore = {
  maps: new Map(),
  meta: { provider: null, range: null, currencies: [], loadedAt: null }
};
function fxClear() {
  fxStore.maps.clear();
  fxStore.meta = { provider:null, range:null, currencies:[], loadedAt:null };
}
function fxCurrenciesLoaded() {
  return Array.from(fxStore.maps.keys()).sort();
}
function fxRateSync(currency, isoDate) {
  const ccy = String(currency||"").toUpperCase();
  if (ccy === "UAH") return 1;
  const mp = fxStore.maps.get(ccy);
  if (!mp) return null;
  if (mp.has(isoDate)) return mp.get(isoDate);

  // fallback: беремо попередній робочий день (до 10 днів назад)
  let d = new Date(isoDate + "T00:00:00");
  for (let i=0;i<10;i++) {
    d.setDate(d.getDate() - 1);
    const iso = d.toISOString().slice(0,10);
    if (mp.has(iso)) return mp.get(iso);
  }
  return null;
}

function loadFxFromBundle(bundle) {
  fxStore.maps.clear();
  const currencies = [];
  for (const [ccy0, dateMap] of Object.entries(bundle.currencies || {})) {
    const ccy = String(ccy0).toUpperCase();
    const mp = new Map();
    for (const [d, r] of Object.entries(dateMap || {})) {
      const rate = Number(r);
      if (!Number.isFinite(rate)) continue;
      mp.set(d, rate);
    }
    if (mp.size) {
      fxStore.maps.set(ccy, mp);
      currencies.push(ccy);
    }
  }
  fxStore.meta.provider = "BUNDLE";
  fxStore.meta.range = bundle.range || null;
  fxStore.meta.currencies = currencies.sort();
  fxStore.meta.loadedAt = new Date().toISOString();
}
function loadFxFromNbuArray(nbuArray) {
  if (!Array.isArray(nbuArray)) throw new Error("JSON НБУ: очікую масив.");
  let ccy = null;
  for (const it of nbuArray) {
    if (it && it.cc) { ccy = String(it.cc).toUpperCase(); break; }
  }
  if (!ccy) throw new Error("JSON НБУ: не знайдено код валюти (поле cc).");

  const mp = fxStore.maps.get(ccy) ?? new Map();
  for (const it of nbuArray) {
    const iso = ddmmyyyy_to_iso(it.exchangedate);
    if (!iso) continue;
    const rate = Number(it.rate);
    if (!Number.isFinite(rate)) continue;
    mp.set(iso, rate);
  }
  fxStore.maps.set(ccy, mp);
  fxStore.meta.provider = fxStore.meta.provider || "NBU_FILES";
  fxStore.meta.loadedAt = new Date().toISOString();
}

async function loadFxFromFiles(files, progressCb) {
  if (!files || !files.length) throw new Error("Не обрано JSON‑файли курсів.");
  const progress = progressCb || (()=>{});
  let loadedBundle = false;

  for (const f of files) {
    progress(`Читаю ${f.name}…`);
    const text = await f.text();
    let data;
    try { data = JSON.parse(text); }
    catch { throw new Error(`Файл ${f.name}: це не JSON.`); }

    if (data && data.format === "fx_bundle_v1" && data.currencies) {
      loadFxFromBundle(data);
      loadedBundle = true;
      progress(`Завантажено bundle: валюти ${fxCurrenciesLoaded().join(", ") || "—"}`);
      continue;
    }

    if (Array.isArray(data)) {
      loadFxFromNbuArray(data);
      progress(`Завантажено (raw НБУ): ${fxCurrenciesLoaded().join(", ")}`);
      continue;
    }

    throw new Error(`Файл ${f.name}: невідомий формат (очікую fx_bundle_v1 або raw‑масив НБУ).`);
  }

  if (!loadedBundle) {
    fxStore.meta.currencies = fxCurrenciesLoaded();
  }
}

async function downloadNbuFxBundleOnline(needs, progressCb) {
  const progress = progressCb || (()=>{});
  const bundle = {
    format: "fx_bundle_v1",
    provider: "NBU",
    generatedAt: new Date().toISOString(),
    range: { start: needs.startIso, end: needs.endIso },
    currencies: {}
  };

  for (const ccy of needs.currencies) {
    progress(`Завантажую ${ccy}…`);
    const url = buildNbuRangeUrl(ccy, needs.startIso, needs.endIso);

    let res;
    try {
      res = await fetch(url);
    } catch (e) {
      throw new Error(
        `Не вдалося завантажити курси НБУ автоматично (Failed to fetch).\n\n` +
        `Що робити:\n` +
        `1) Натисніть “Показати посилання НБУ (fallback)” і збережіть JSON вручну\n` +
        `2) Або відкрийте HTML через http://localhost (python -m http.server)\n\n` +
        `URL: ${url}`
      );
    }
    if (!res.ok) throw new Error(`НБУ: HTTP ${res.status} для ${ccy}`);

    const data = await res.json();
    const map = {};
    for (const it of data) {
      const iso = ddmmyyyy_to_iso(it.exchangedate);
      if (!iso) continue;
      const rate = Number(it.rate);
      if (!Number.isFinite(rate)) continue;
      map[iso] = rate;
    }
    if (Object.keys(map).length === 0) throw new Error(`НБУ: порожні дані для ${ccy}.`);

    bundle.currencies[ccy] = map;
  }

  progress(`Готово ✅ Завантажено валют: ${Object.keys(bundle.currencies).length}`);
  return bundle;
}

/* =========================
   FX needs + links
========================= */
function computeFxNeeds(statement, taxYear) {
  const yPrefix = String(taxYear) + "-";
  let minDate = null;
  let maxDate = null;

  for (const t of statement.trades) {
    minDate = minIso(minDate, t.tradeDate);
    maxDate = maxIso(maxDate, t.tradeDate);
  }

  for (const ci of statement.cashIncomes) {
    if (!ci.date || !ci.date.startsWith(yPrefix)) continue;
    minDate = minIso(minDate, ci.date);
    maxDate = maxIso(maxDate, ci.date);
  }
  for (const w of statement.withholdings) {
    if (!w.date || !w.date.startsWith(yPrefix)) continue;
    minDate = minIso(minDate, w.date);
    maxDate = maxIso(maxDate, w.date);
  }

  const asOf = statement.meta.asOfDate || statement.meta.periodEnd;
  if (asOf) {
    minDate = minIso(minDate, asOf);
    maxDate = maxIso(maxDate, asOf);
  }

  if (!minDate) minDate = statement.meta.periodStart || `${taxYear}-01-01`;
  if (!maxDate) maxDate = statement.meta.periodEnd || `${taxYear}-12-31`;

  const curSet = new Set();
  for (const t of statement.trades) curSet.add(t.asset.currency);
  for (const ci of statement.cashIncomes) if (ci.date && ci.date.startsWith(yPrefix)) curSet.add(ci.currency);
  for (const w of statement.withholdings) if (w.date && w.date.startsWith(yPrefix)) curSet.add(w.currency);
  for (const p of statement.positions) curSet.add(p.asset.currency);
  curSet.delete("UAH");

  return { startIso: minDate, endIso: maxDate, currencies: Array.from(curSet).sort() };
}

function buildFxLinksHtml(needs) {
  const items = needs.currencies.map(ccy => {
    const url = buildNbuRangeUrl(ccy, needs.startIso, needs.endIso);
    return `• <b>${escapeHtml(ccy)}</b>: <a target="_blank" rel="noreferrer" href="${escapeHtml(url)}">${escapeHtml(url)}</a>`;
  });

  const intro = [
    `<b>Посилання НБУ (JSON)</b><br/>`,
    `Діапазон: <span class="mono">${escapeHtml(needs.startIso)} → ${escapeHtml(needs.endIso)}</span><br/>`,
    `Валюти: <span class="mono">${escapeHtml(needs.currencies.join(", ") || "—")}</span><br/><br/>`,
    `<b>Як зробити офлайн‑курси:</b><br/>`,
    `1) Відкрийте кожне посилання<br/>`,
    `2) Збережіть JSON (наприклад USD.json, EUR.json)<br/>`,
    `3) Оберіть JSON‑файли та натисніть “Підвантаж JSON‑файли”<br/><br/>`,
  ].join("");

  return intro + items.join("<br/>");
}
function downloadFxLinksFile(needs) {
  const html = `
<!doctype html>
<html lang="uk"><head><meta charset="utf-8" />
<title>Посилання НБУ</title></head>
<body style="font-family:Arial,sans-serif;">
  <h2>Посилання НБУ (JSON)</h2>
  <p><b>Діапазон:</b> ${needs.startIso} → ${needs.endIso}</p>
  <p><b>Валюти:</b> ${needs.currencies.join(", ")}</p>
  <p>Відкрийте кожне посилання, збережіть JSON (USD.json/EUR.json...), потім завантажте їх у калькулятор.</p>
  <ul>
    ${needs.currencies.map(ccy => {
      const url = buildNbuRangeUrl(ccy, needs.startIso, needs.endIso);
      return `<li><b>${ccy}</b>: <a href="${url}" target="_blank" rel="noreferrer">${url}</a></li>`;
    }).join("\n")}
  </ul>
</body></html>`;
  downloadBlob(`nbu_fx_links_${needs.startIso}_${needs.endIso}.html`, "text/html;charset=utf-8", html);
}

function assertFxCoverage(statement, taxYear) {
  const needs = computeFxNeeds(statement, taxYear);
  if (!needs.currencies.length) return;

  const needDates = new Map();
  const add = (ccy, date) => {
    const C = String(ccy||"").toUpperCase();
    if (!C || C === "UAH" || !date) return;
    if (!needDates.has(C)) needDates.set(C, new Set());
    needDates.get(C).add(date);
  };

  for (const t of statement.trades) add(t.asset.currency, t.tradeDate);

  const yPrefix = String(taxYear) + "-";
  for (const ci of statement.cashIncomes) if (ci.date && ci.date.startsWith(yPrefix)) add(ci.currency, ci.date);
  for (const w of statement.withholdings) if (w.date && w.date.startsWith(yPrefix)) add(w.currency, w.date);

  const asOf = statement.meta.asOfDate || statement.meta.periodEnd;
  if (asOf) for (const p of statement.positions) add(p.asset.currency, asOf);

  const problems = [];
  for (const [ccy, set] of needDates.entries()) {
    if (!fxStore.maps.has(ccy)) {
      problems.push({ ccy, date: "(немає даних по валюті)" });
      if (problems.length >= 25) break;
      continue;
    }
    for (const d of set.values()) {
      const r = fxRateSync(ccy, d);
      if (!r) {
        problems.push({ ccy, date: d });
        if (problems.length >= 25) break;
      }
    }
    if (problems.length >= 25) break;
  }

  if (problems.length) {
    const examples = problems.map(x => `${x.ccy} @ ${x.date}`).join(", ");
    throw new Error(
      "Курси завантажені не повністю: немає ставок для деяких валют/дат.\n" +
      "Приклади: " + examples + "\n\n" +
      "Що робити:\n" +
      "• Натисніть “Показати посилання НБУ (fallback)”\n" +
      "• Збережіть JSON по потрібних валютах на вказаний діапазон\n" +
      "• Натисніть “Підвантаж JSON‑файли” та повторіть розрахунок"
    );
  }
}

/* =========================
   FIFO engine (cashflow-based)
========================= */
function sign(x){ return x>0?1:x<0?-1:0; }
function abs(x){ return Math.abs(x); }
function allocPart(total, partQtyAbs, totalQtyAbs) {
  if (totalQtyAbs === 0) return 0;
  return total * (partQtyAbs / totalQtyAbs);
}
async function fifoInUAH(trades) {
  const sorted = trades.slice().sort((a,b) => a.dateTime.localeCompare(b.dateTime));
  const books = new Map();
  const matches = [];

  for (const tr of sorted) {
    const assetKey = tr.asset.assetKey;
    const date = tr.tradeDate;

    const rate = fxRateSync(tr.asset.currency, date);
    if (!rate) throw new Error(`Немає курсу для ${tr.asset.currency} на ${date}.`);

    let qtyRem = tr.quantity;
    let cashRemUAH = tr.netCash * rate;

    let queue = books.get(assetKey) || [];

    while (queue.length > 0 && sign(qtyRem) !== 0 && sign(qtyRem) !== sign(queue[0].qtySigned)) {
      const lot = queue[0];

      const lotQtyAbs = abs(lot.qtySigned);
      const trQtyAbs  = abs(qtyRem);
      const matchQtyAbs = Math.min(lotQtyAbs, trQtyAbs);

      const lotCashPart = allocPart(lot.cashUAH, matchQtyAbs, lotQtyAbs);
      const trCashPart  = allocPart(cashRemUAH, matchQtyAbs, trQtyAbs);

      const openCashUAH  = lotCashPart;
      const closeCashUAH = trCashPart;

      const incomeUAH  = Math.max(openCashUAH, 0) + Math.max(closeCashUAH, 0);
      const expenseUAH = -Math.min(openCashUAH, 0) + -Math.min(closeCashUAH, 0);
      const pnlUAH     = openCashUAH + closeCashUAH;

      matches.push({
        assetKey,
        qtyAbs: matchQtyAbs,
        openDate: lot.openDate,
        closeDate: date,
        incomeUAH,
        expenseUAH,
        pnlUAH,
      });

      const lotS = sign(lot.qtySigned);
      lot.qtySigned = lot.qtySigned - lotS * matchQtyAbs;
      lot.cashUAH   = lot.cashUAH   - lotCashPart;

      const trS = sign(qtyRem);
      qtyRem     = qtyRem     - trS * matchQtyAbs;
      cashRemUAH = cashRemUAH - trCashPart;

      if (abs(lot.qtySigned) < 1e-12) queue.shift();
    }

    if (abs(qtyRem) >= 1e-12) {
      queue.push({ qtySigned: qtyRem, cashUAH: cashRemUAH, openDate: date });
    }
    books.set(assetKey, queue);
  }

  return { matches, books };
}

/* =========================
   F1 + dividends taxes
========================= */
function buildF1ModeFromUI() {
  const mode = $("#f1AssetTypeMode").value;
  if (mode === "MANUAL") {
    try {
      const m = JSON.parse($("#f1ManualMap").value || "{}");
      return { mode: "MANUAL", map: m };
    } catch {
      return { mode: "MANUAL", map: {} };
    }
  }
  return { mode: "ALL_4" };
}
function inferF1AssetType(assetKey, f1Mode) {
  if (f1Mode.mode === "ALL_4") return 4;
  const v = f1Mode.map?.[assetKey];
  if (v === 1 || v === 2 || v === 3 || v === 4) return v;
  return 4;
}
function buildF1Model(statement, assetIndex, matches, settings) {
  const y = String(settings.taxYear) + "-";
  const inYear = matches.filter(m => m.closeDate.startsWith(y));

  const byAsset = new Map();
  for (const m of inYear) {
    const cur = byAsset.get(m.assetKey) || { income: 0, cost: 0, result: 0 };
    cur.income += m.incomeUAH;
    cur.cost   += m.expenseUAH;
    cur.result += m.pnlUAH;
    byAsset.set(m.assetKey, cur);
  }

  let n = 1;
  const rows = [];
  for (const [assetKey, agg] of byAsset.entries()) {
    rows.push({
      n: n++,
      assetKey,
      assetType: inferF1AssetType(assetKey, settings.f1Mode),
      name: humanNameFromAssetKey(assetIndex, assetKey),
      incomeUAH: round2(agg.income),
      costUAH: round2(agg.cost),
      resultUAH: round2(agg.income - agg.cost),
    });
  }

  const totalIncomeUAH = round2(rows.reduce((s,r)=>s+r.incomeUAH,0));
  const totalCostUAH   = round2(rows.reduce((s,r)=>s+r.costUAH,0));
  const totalResultUAH = round2(rows.reduce((s,r)=>s+r.resultUAH,0));

  const carryLossUAH = round2(Math.max(0, settings.carryLossUAH || 0));
  const netResultUAH = round2(totalResultUAH - carryLossUAH);
  const netProfitUAH = netResultUAH > 0 ? netResultUAH : 0;
  const netLossUAH   = netResultUAH < 0 ? round2(-netResultUAH) : 0;

  const pitUAH = round2(netProfitUAH * settings.pitInvestRate);
  const milUAH = round2(netProfitUAH * settings.milInvestRate);

  const operations = inYear
    .slice()
    .sort((a,b)=>a.closeDate.localeCompare(b.closeDate))
    .map(m => ({
      closeDate: m.closeDate,
      assetKey: m.assetKey,
      qtyAbs: m.qtyAbs,
      incomeUAH: round2(m.incomeUAH),
      costUAH: round2(m.expenseUAH),
      resultUAH: round2(m.pnlUAH),
    }));

  return {
    taxYear: settings.taxYear,
    rows,
    totals: {
      totalIncomeUAH, totalCostUAH, totalResultUAH,
      carryLossUAH,
      netResultUAH,
      netProfitUAH,
      netLossUAH
    },
    investTaxes: { pitUAH, milUAH, pitDueUAH: pitUAH, milDueUAH: milUAH },
    operations
  };
}

async function computeDividendsUAH(statement, settings) {
  const y = String(settings.taxYear) + "-";
  const div = statement.cashIncomes.filter(ci => {
    if (!ci.date || !ci.date.startsWith(y)) return false;
    if (ci.kind === "DIVIDEND") return true;
    if (settings.treatPILasDividend && ci.kind === "PIL_DIVIDEND") return true;
    return false;
  });

  let totalUAH = 0;
  for (const d of div) {
    const r = fxRateSync(d.currency, d.date);
    if (!r) throw new Error(`Немає курсу для ${d.currency} на ${d.date} (дивіденди).`);
    totalUAH += d.amount * r;
  }
  return { items: div, totalUAH: totalUAH };
}

async function computeWithholdingOnDivUAH(statement, settings) {
  const y = String(settings.taxYear) + "-";
  const items = statement.withholdings.filter(w => {
    if (!w.date || !w.date.startsWith(y)) return false;
    const d = String(w.description || "").toLowerCase();
    if (d.includes("dividend")) return true;
    if (settings.treatPILasDividend && d.includes("payment in lieu")) return true;
    return false;
  });

  let totalUAH = 0;
  for (const w of items) {
    const r = fxRateSync(w.currency, w.date);
    if (!r) throw new Error(`Немає курсу для ${w.currency} на ${w.date} (утримання).`);
    totalUAH += Math.abs(w.amount) * r;
  }
  return { items, totalUAH };
}

/* =========================
   Declaration hints (XLSX sheet)
========================= */
function getDividendItemsForYear(statement, taxYear, treatPILasDividend) {
  const y = String(taxYear) + "-";
  return (statement?.cashIncomes || []).filter(ci => {
    if (!ci?.date || !ci.date.startsWith(y)) return false;
    if (ci.kind === "DIVIDEND") return true;
    if (treatPILasDividend && ci.kind === "PIL_DIVIDEND") return true;
    return false;
  });
}

function buildDeclarationHintsAoA(statement, f1, taxSummary, settings) {
  const year = f1.taxYear;

  const investProfit = taxSummary.invest.netProfitUAH;
  const investPIT    = taxSummary.invest.pitUAH;
  const investMIL    = taxSummary.invest.milUAH;

  const divIncome     = taxSummary.dividends.dividendsUAH;         // gross
  const divPITgross   = taxSummary.dividends.pitGrossUAH;          // gross PIT
  const divWithheld   = taxSummary.dividends.withholdingDivUAH;    // утримано
  const divCredit     = taxSummary.dividends.creditUAH;            // залік (якщо увімкнено)
  const divMIL        = taxSummary.dividends.milUAH;

  const totalPIT = taxSummary.totals.pitUAH;
  const totalMIL = taxSummary.totals.milUAH;
  const totalAll = taxSummary.totals.totalUAH;

  const treatPIL = settings?.treatPILasDividend ?? true;
  const divItems = getDividendItemsForYear(statement, year, treatPIL);
  const divCurrencies = Array.from(new Set(divItems.map(d => d.currency))).sort();
  const divCurrenciesTxt = divCurrencies.length ? divCurrencies.join(", ") : "—";

  // Орієнтир: у 10.8 показуємо прибуток (ряд. 3.1 Ф1), а не оборот
  const row108_income = Math.max(0, investProfit);

  // Орієнтир: іноземні дивіденди — 10.10
  const row1010_income = Math.max(0, divIncome);
  const row1010_pit_gross = Math.max(0, divPITgross);
  const row1010_mil = Math.max(0, divMIL);

  // Контрольні суми (якщо, крім інвестприбутку та іноземних дивідендів, інших доходів немає)
  const expected_row13 = investPIT + row1010_pit_gross;
  const expected_row18 = Math.max(0, divCredit);
  const expected_row201 = totalPIT;
  const expected_row211 = investMIL + row1010_mil;

  return [
    [`Підказки для заповнення декларації про майновий стан і доходи за ${year} рік`],
    [`Увага: це довідкові підказки, не податкова консультація. Перевіряйте актуальну форму та інструкції ДПС.`],
    [],
    [`Ключові суми (грн)`],
    ["Інвестприбуток (Ф1, рядок 3.1)", fmt2(row108_income)],
    ["ПДФО з інвестприбутку (Ф1, розд. II)", fmt2(investPIT)],
    ["ВЗ з інвестприбутку (Ф1, розд. II)", fmt2(investMIL)],
    [],
    ["Іноземні дивіденди (gross)", fmt2(row1010_income)],
    ["ПДФО на іноземні дивіденди (gross)", fmt2(row1010_pit_gross)],
    ["Утримано за кордоном (дивіденди)", fmt2(divWithheld)],
    ["Залік застосовано?", (settings?.useForeignTaxCredit ? "Так" : "Ні")],
    ["Залік (сума до розд. V, рядок 18)", fmt2(expected_row18)],
    ["ВЗ на іноземні дивіденди", fmt2(row1010_mil)],
    [],
    ["Разом до сплати (за розрахунком)", ""],
    ["ПДФО всього", fmt2(totalPIT)],
    ["ВЗ всього", fmt2(totalMIL)],
    ["Разом", fmt2(totalAll)],
    [],
    ["Куди переносити у декларації (орієнтир по вашому XLS‑зразку):", "", ""],
    ["Розділ II, рядок 10.8 (Інвестиційний прибуток), графа 3 «Сума доходів»", fmt2(row108_income), "зразок: 'Деклар 2024'!AK64"],
    ["Розділ II, рядок 10.8, графа 6 «ПДФО до сплати самостійно»", fmt2(investPIT), "зразок: 'Деклар 2024'!BE64"],
    ["Розділ II, рядок 10.8, графа 7 «ВЗ до сплати самостійно»", fmt2(investMIL), "зразок: 'Деклар 2024'!BL64"],
    [],
    ["Розділ II, рядок 10.10 (Доходи з джерел за межами України), графа 3 «Сума доходів»", fmt2(row1010_income), "зразок: 'Деклар 2024'!AK66"],
    ["Розділ II, рядок 10.10, графа 6 «ПДФО (gross)»", fmt2(row1010_pit_gross), "зразок: 'Деклар 2024'!BE66"],
    ["Розділ II, рядок 10.10, графа 7 «ВЗ»", fmt2(row1010_mil), "зразок: 'Деклар 2024'!BL66"],
    [],
    ["Розділ V, рядок 13 (загальна сума зобов'язань ПДФО; графа 6 рядка 10)", fmt2(expected_row13), "зразок: 'Деклар 2024'!BE84"],
    ["Розділ V, рядок 18 (залік податку, сплаченого за кордоном)", fmt2(expected_row18), "зразок: 'Деклар 2024'!BE89"],
    ["Розділ V, рядок 20.1 (ПДФО до сплати)", fmt2(expected_row201), "зразок: 'Деклар 2024'!BE92"],
    ["Розділ V, рядок 21.1 (ВЗ до сплати; графа 7 рядка 10)", fmt2(expected_row211), "зразок: 'Деклар 2024'!BE96"],
    [],
    ["Примітки:", "", ""],
    [`• Валюта(и) дивідендів у звіті IB за ${year}: ${divCurrenciesTxt}. Країну джерела доходу вказуйте відповідно до емітентів/документів.`, "", ""],
    ["• Для іноземних дивідендів: ПДФО у рядку 10.10 — «gross», а залік показуйте окремо у розд. V рядок 18, щоб не занизити ПДФО двічі.", "", ""],
    ["• ВЗ (військовий збір) заліком не зменшується.", "", ""],
    ["• Додаток Ф1 — див. аркуш «F1» у цьому XLSX; деталізація FIFO — аркуш(і) «Ops…».", "", ""],
  ];
}

/* =========================
   Render tables
========================= */
function renderTable(el, columns, rows) {
  const thead = "<thead><tr>" + columns.map(c => `<th>${escapeHtml(c.label)}</th>`).join("") + "</tr></thead>";
  const tbody = "<tbody>" + rows.map(r => {
    return "<tr>" + columns.map(c => {
      let v = (typeof c.value === "function") ? c.value(r) : r[c.value];
      if (c.num && Number.isFinite(v)) v = fmt2(v);
      const cls = c.num ? "num" : "";
      return `<td class="${cls}">${escapeHtml(v)}</td>`;
    }).join("") + "</tr>";
  }).join("") + "</tbody>";
  el.innerHTML = thead + tbody;
}
function firstN(arr, n){ return arr.slice(0, Math.min(n, arr.length)); }

/* =========================
   Exports (CSV / XLSX / Print) + huge ops handling
========================= */
async function ensureSheetJS() {
  if (window.XLSX) return true;
  return new Promise((resolve) => {
    const s = document.createElement("script");
    s.src = "https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js";
    s.onload = () => resolve(true);
    s.onerror = () => resolve(false);
    document.head.appendChild(s);
  });
}

function exportCsvF1AndOps(f1) {
  // F1
  const f1Rows = [
    ["№","Код","Найменування","Дохід (грн)","Витрати (грн)","Результат (грн)","assetKey"],
    ...f1.rows.map(r => [r.n, r.assetType, r.name, fmt2(r.incomeUAH), fmt2(r.costUAH), fmt2(r.resultUAH), r.assetKey])
  ];
  downloadBlob(`F1_${f1.taxYear}.csv`, "text/csv;charset=utf-8", toCsv(f1Rows));

  // Operations — може бути дуже багато → ділимо на частини
  const header = ["Дата закриття","assetKey","К-ть (abs)","Дохід (грн)","Витрати (грн)","Результат (грн)"];
  const dataRows = f1.operations.map(o => [o.closeDate, o.assetKey, o.qtyAbs, fmt2(o.incomeUAH), fmt2(o.costUAH), fmt2(o.resultUAH)]);

  const MAX_DATA_ROWS_PER_FILE = 900000;
  if (dataRows.length <= MAX_DATA_ROWS_PER_FILE) {
    downloadBlob(`Operations_${f1.taxYear}.csv`, "text/csv;charset=utf-8", toCsv([header, ...dataRows]));
  } else {
    let part = 1;
    for (let i = 0; i < dataRows.length; i += MAX_DATA_ROWS_PER_FILE) {
      const slice = dataRows.slice(i, i + MAX_DATA_ROWS_PER_FILE);
      downloadBlob(`Operations_${f1.taxYear}_part${part}.csv`, "text/csv;charset=utf-8", toCsv([header, ...slice]));
      part++;
    }
  }
}

function exportPrintableF1(f1) {
  const rowsHtml = f1.rows.map(r => `
    <tr>
      <td>${r.n}</td>
      <td>${r.assetType}</td>
      <td>${escapeHtml(r.name)}</td>
      <td class="num">${escapeHtml(fmt2(r.incomeUAH))}</td>
      <td class="num">${escapeHtml(fmt2(r.costUAH))}</td>
      <td class="num">${escapeHtml(fmt2(r.resultUAH))}</td>
    </tr>`).join("");

  const html = `
<!doctype html>
<html lang="uk"><head><meta charset="utf-8" />
<title>Ф1 ${f1.taxYear}</title>
<style>
  body { font-family: Arial, sans-serif; font-size: 12px; }
  h1 { font-size: 16px; margin: 0 0 10px 0; }
  h2 { font-size: 14px; margin: 14px 0 8px; }
  table { width: 100%; border-collapse: collapse; }
  th, td { border: 1px solid #000; padding: 4px; vertical-align: top; }
  .num { text-align: right; white-space: nowrap; font-variant-numeric: tabular-nums; }
  @media print { button { display: none; } }
</style>
</head><body>
<button onclick="window.print()">Друк / Зберегти як PDF</button>
<h1>Додаток Ф1 — розрахунок інвестиційного прибутку за ${f1.taxYear} рік</h1>

<table>
  <thead>
    <tr>
      <th>№</th>
      <th>Вид (код)</th>
      <th>Найменування та характеристика</th>
      <th>Дохід (грн)</th>
      <th>Витрати (грн)</th>
      <th>Фін. результат (грн)</th>
    </tr>
  </thead>
  <tbody>
    ${rowsHtml}
    <tr>
      <td colspan="3"><b>УСЬОГО</b></td>
      <td class="num"><b>${escapeHtml(fmt2(f1.totals.totalIncomeUAH))}</b></td>
      <td class="num"><b>${escapeHtml(fmt2(f1.totals.totalCostUAH))}</b></td>
      <td class="num"><b>${escapeHtml(fmt2(f1.totals.totalResultUAH))}</b></td>
    </tr>
  </tbody>
</table>

<h2>Підсумок</h2>
<p><b>Рядок 2 (перенесений збиток):</b> ${escapeHtml(fmt2(f1.totals.carryLossUAH))} грн</p>
<p><b>Рядок 3 (загальний фінрезультат):</b> ${escapeHtml(fmt2(f1.totals.netResultUAH))} грн</p>
<p><b>Рядок 3.1 (прибуток):</b> ${escapeHtml(fmt2(f1.totals.netProfitUAH))} грн</p>
<p><b>Рядок 3.2 (збиток):</b> ${escapeHtml(fmt2(f1.totals.netLossUAH))} грн</p>

<h2>Розділ II</h2>
<p><b>ПДФО:</b> ${escapeHtml(fmt2(f1.investTaxes.pitUAH))} грн</p>
<p><b>Військовий збір:</b> ${escapeHtml(fmt2(f1.investTaxes.milUAH))} грн</p>
</body></html>`;
  const w = window.open("", "_blank");
  if (!w) throw new Error("Блокування спливаючих вікон (дозвольте pop‑up).");
  w.document.open();
  w.document.write(html);
  w.document.close();
}

async function exportXlsx(statement, f1, taxSummary, settings) {
  const ok = await ensureSheetJS();
  if (!ok || !window.XLSX) {
    alert("Не вдалося завантажити бібліотеку XLSX (можливо, немає інтернету). Використайте CSV або друк.");
    return;
  }
  const XLSX = window.XLSX;
  const wb = XLSX.utils.book_new();

  // Summary
  const sum = [
    [`Підсумок ${f1.taxYear}`],
    [],
    ["ІНВЕСТ‑РЕЗУЛЬТАТ (FIFO, грн)"],
    ["Дохід", fmt2(taxSummary.invest.incomeUAH)],
    ["Витрати", fmt2(taxSummary.invest.costUAH)],
    ["Фінрезультат", fmt2(taxSummary.invest.resultUAH)],
    ["Перенесений збиток", fmt2(taxSummary.invest.carryLossUAH)],
    ["Підсумок (ряд.3)", fmt2(taxSummary.invest.netResultUAH)],
    ["Прибуток (ряд.3.1)", fmt2(taxSummary.invest.netProfitUAH)],
    ["ПДФО (інвест)", fmt2(taxSummary.invest.pitUAH)],
    ["ВЗ (інвест)", fmt2(taxSummary.invest.milUAH)],
    ["К-ть FIFO‑операцій (за рік)", String(f1.operations.length)],
    [],
    ["ДИВІДЕНДИ (грн)"],
    ["Дивіденди", fmt2(taxSummary.dividends.dividendsUAH)],
    ["Утримано (div)", fmt2(taxSummary.dividends.withholdingDivUAH)],
    ["ПДФО (gross)", fmt2(taxSummary.dividends.pitGrossUAH)],
    ["Залік", fmt2(taxSummary.dividends.creditUAH)],
    ["ПДФО до сплати", fmt2(taxSummary.dividends.pitDueUAH)],
    ["ВЗ до сплати", fmt2(taxSummary.dividends.milUAH)],
    [],
    ["РАЗОМ"],
    ["ПДФО всього", fmt2(taxSummary.totals.pitUAH)],
    ["ВЗ всього", fmt2(taxSummary.totals.milUAH)],
    ["Всього до сплати", fmt2(taxSummary.totals.totalUAH)],
  ];
  const wsSum = XLSX.utils.aoa_to_sheet(sum);
  wsSum["!cols"] = [{wch:30},{wch:28}];
  XLSX.utils.book_append_sheet(wb, wsSum, "Summary");

  // Декларація (підказки + готові суми для перенесення)
  const declAoA = buildDeclarationHintsAoA(statement, f1, taxSummary, settings);
  const wsDecl = XLSX.utils.aoa_to_sheet(declAoA);
  wsDecl["!cols"] = [{wch:70},{wch:22},{wch:45}];
  XLSX.utils.book_append_sheet(wb, wsDecl, "Декларація");

  // F1
  const f1Head = [
    [`Додаток Ф1 за ${f1.taxYear} рік`],
    [],
    ["№","Вид (код)","Найменування та характеристика","Дохід (грн)","Витрати (грн)","Фін. результат (грн)","assetKey"]
  ];
  const f1Rows = f1.rows.map(r => [r.n, r.assetType, r.name, fmt2(r.incomeUAH), fmt2(r.costUAH), fmt2(r.resultUAH), r.assetKey]);
  const f1Totals = [
    [],
    ["","","УСЬОГО", fmt2(f1.totals.totalIncomeUAH), fmt2(f1.totals.totalCostUAH), fmt2(f1.totals.totalResultUAH)],
    [],
    ["Рядок 2", fmt2(f1.totals.carryLossUAH)],
    ["Рядок 3", fmt2(f1.totals.netResultUAH)],
    ["Рядок 3.1", fmt2(f1.totals.netProfitUAH)],
    ["Рядок 3.2", fmt2(f1.totals.netLossUAH)],
    [],
    ["ПДФО", fmt2(f1.investTaxes.pitUAH)],
    ["Військовий збір", fmt2(f1.investTaxes.milUAH)],
  ];
  const wsF1 = XLSX.utils.aoa_to_sheet([...f1Head, ...f1Rows, ...f1Totals]);
  wsF1["!cols"] = [{wch:6},{wch:10},{wch:65},{wch:18},{wch:18},{wch:18},{wch:38}];
  XLSX.utils.book_append_sheet(wb, wsF1, "F1");

  // Operations — не обрізаємо: ділимо по листах
  const EXCEL_MAX_ROWS = 1048576;
  const HEADER_ROWS = 3;
  const MAX_DATA_PER_SHEET = EXCEL_MAX_ROWS - HEADER_ROWS;

  const opsData = f1.operations;
  const parts = Math.max(1, Math.ceil(opsData.length / MAX_DATA_PER_SHEET));

  for (let p=0; p<parts; p++) {
    const from = p * MAX_DATA_PER_SHEET;
    const to = Math.min(opsData.length, (p+1) * MAX_DATA_PER_SHEET);
    const slice = opsData.slice(from, to);

    const opsAoA = [
      [`Операції (FIFO‑зіставлення) ${f1.taxYear} — частина ${p+1}/${parts} (рядки ${from+1}-${to})`],
      [],
      ["Дата закриття","assetKey","К-ть (abs)","Дохід (грн)","Витрати (грн)","Результат (грн)"],
      ...slice.map(o => [o.closeDate, o.assetKey, o.qtyAbs, fmt2(o.incomeUAH), fmt2(o.costUAH), fmt2(o.resultUAH)])
    ];
    const wsOps = XLSX.utils.aoa_to_sheet(opsAoA);
    wsOps["!cols"] = [{wch:12},{wch:42},{wch:12},{wch:18},{wch:18},{wch:18}];

    const sheetName = (parts === 1) ? "Ops" : `Ops_${p+1}`;
    XLSX.utils.book_append_sheet(wb, wsOps, sheetName);
  }

  XLSX.writeFile(wb, `IB_Taxes_${f1.taxYear}_F1.xlsx`);
}

/* =========================
   Open positions: top losers
========================= */
async function computeTopLosers(statement, asOfDate, topN, netProfitUAH, pitRate, milRate) {
  const scored = [];
  for (const p of statement.positions) {
    const r = fxRateSync(p.asset.currency, asOfDate);
    if (!r) continue;
    const uah = p.unrealizedPL * r;
    scored.push({ p, unrealizedUAH: uah });
  }
  scored.sort((a,b)=>a.unrealizedUAH - b.unrealizedUAH);
  const top = scored.slice(0, Math.max(1, topN|0));

  return top.map(x => {
    const lossUAH = x.unrealizedUAH < 0 ? -x.unrealizedUAH : 0;
    const reducible = Math.min(lossUAH, Math.max(0, netProfitUAH));
    const estTaxSaved = reducible * (pitRate + milRate);
    return { ...x, lossUAH, reducible, estTaxSaved };
  });
}

/* =========================
   App state + settings
========================= */
const state = {
  statement: null,
  assetIndex: null,
  fifo: null,
  f1: null,
  taxSummary: null,
  fxNeeds: null,
};

function readSettings() {
  return {
    taxYear: Number($("#taxYear").value),
    pitInvestRate: Number($("#pitInvestRate").value),
    milInvestRate: Number($("#milInvestRate").value),
    pitDivRate: Number($("#pitDivRate").value),
    milDivRate: Number($("#milDivRate").value),
    carryLossUAH: Number($("#carryLossUAH").value),
    useForeignTaxCredit: $("#useForeignTaxCredit").checked,
    treatPILasDividend: $("#treatPILasDividend").checked,
    f1Mode: buildF1ModeFromUI(),
  };
}

function updateFxUi() {
  const fxStatus = $("#fxStatus");
  const btnDownloadFx = $("#btnDownloadFx");
  const btnShowFxLinks = $("#btnShowFxLinks");
  const btnDownloadFxLinksFile = $("#btnDownloadFxLinksFile");
  const btnClearFx = $("#btnClearFx");

  if (!state.statement) {
    setStatus(fxStatus, "Спочатку розпізнайте CSV, щоб визначити потрібні валюти та дати.");
    btnDownloadFx.disabled = true;
    btnShowFxLinks.disabled = true;
    btnDownloadFxLinksFile.disabled = true;
    btnClearFx.disabled = fxCurrenciesLoaded().length === 0;
    return;
  }

  const settings = readSettings();
  const needs = computeFxNeeds(state.statement, settings.taxYear);
  state.fxNeeds = needs;

  const loaded = fxCurrenciesLoaded();
  const needText = needs.currencies.length ? needs.currencies.join(", ") : "—";
  const loadedText = loaded.length ? loaded.join(", ") : "—";
  const rangeText = `${needs.startIso} → ${needs.endIso}`;

  const msg = [
    `Потрібні валюти: ${needText}`,
    `Діапазон: ${rangeText}`,
    ``,
    `Завантажено валют: ${loadedText}`,
    `Джерело: ${fxStore.meta.provider || "—"}`,
  ].join("\n");

  const readyByCurrency = needs.currencies.every(c => fxStore.maps.has(String(c).toUpperCase()));
  const kind = needs.currencies.length === 0 ? "good" : (readyByCurrency ? "good" : "warn");
  setStatus(fxStatus, msg, kind);

  btnDownloadFx.disabled = (needs.currencies.length === 0);
  btnShowFxLinks.disabled = (needs.currencies.length === 0);
  btnDownloadFxLinksFile.disabled = (needs.currencies.length === 0);
  btnClearFx.disabled = (loaded.length === 0);

  $("#asOfDate").value = state.statement.meta.asOfDate || state.statement.meta.periodEnd || `${settings.taxYear}-12-31`;
}

function updateReadinessUi() {
  const statusCalc = $("#statusCalc");
  const btnCalc = $("#btnCalc");

  if (!state.statement) {
    btnCalc.disabled = true;
    $("#btnShowLosers").disabled = true;
    setStatus(statusCalc, "Спочатку розпізнайте CSV та підготуйте курси НБУ.");
    return;
  }

  const settings = readSettings();
  const needs = computeFxNeeds(state.statement, settings.taxYear);
  state.fxNeeds = needs;

  const haveAllCurrencies = needs.currencies.every(c => fxStore.maps.has(String(c).toUpperCase()));
  const canCalc = (needs.currencies.length === 0) || haveAllCurrencies;

  btnCalc.disabled = !canCalc;
  $("#btnShowLosers").disabled = !(fxCurrenciesLoaded().length > 0);

  if (!canCalc) {
    setStatus(statusCalc, "Не вистачає курсів НБУ.\nНатисніть “Завантажити курси НБУ (і застосувати)” або “Показати посилання НБУ”, збережіть JSON і натисніть “Підвантаж JSON‑файли”.", "warn");
  } else {
    setStatus(statusCalc, "Готово до розрахунку ✅ Натисніть “Розрахувати податки + сформувати Ф1”.", "good");
  }
}

/* =========================
   Preview render
========================= */
function renderPreview(st) {
  let minD = null, maxD = null;
  const curSet = new Set();

  for (const t of st.trades) { minD = minIso(minD, t.tradeDate); maxD = maxIso(maxD, t.tradeDate); curSet.add(t.asset.currency); }
  for (const ci of st.cashIncomes) { if (ci.date) { minD = minIso(minD, ci.date); maxD = maxIso(maxD, ci.date); curSet.add(ci.currency); } }
  for (const w of st.withholdings) { if (w.date) { minD = minIso(minD, w.date); maxD = maxIso(maxD, w.date); curSet.add(w.currency); } }
  for (const p of st.positions) { curSet.add(p.asset.currency); }

  $("#kpiDates").textContent = (minD && maxD) ? `${minD} → ${maxD}` : "—";
  $("#kpiCurrencies").textContent = Array.from(curSet).sort().join(", ") || "—";
  $("#kpiTrades").textContent = String(st.trades.length);
  $("#kpiOther").textContent = `${st.cashIncomes.length} / ${st.withholdings.length} / ${st.positions.length}`;

  if (st.warnings && st.warnings.length) {
    const lines = st.warnings.slice(0, 30).map(w => `• [${w.code}] ${w.message}`);
    if (st.warnings.length > 30) lines.push(`… і ще ${st.warnings.length - 30}`);
    $("#warningsBox").style.display = "block";
    setStatus($("#warningsBox"), "Попередження:\n" + lines.join("\n"), "warn");
  } else {
    $("#warningsBox").style.display = "none";
  }

  renderTable($("#tblTrades"), [
    { label:"Дата", value:(r)=>r.tradeDate },
    { label:"Символ", value:(r)=>r.asset.symbolRaw },
    { label:"assetKey", value:(r)=>r.asset.assetKey },
    { label:"К-ть", value:(r)=>r.quantity, num:true },
    { label:"Чистий потік (netCash)", value:(r)=>r.netCash, num:true },
    { label:"Валюта", value:(r)=>r.asset.currency },
  ], firstN(st.trades, 200));

  renderTable($("#tblDiv"), [
    { label:"Дата", value:(r)=>r.date },
    { label:"Валюта", value:(r)=>r.currency },
    { label:"Тип", value:(r)=>r.kind },
    { label:"Сума", value:(r)=>r.amount, num:true },
    { label:"Опис", value:(r)=>r.description },
  ], firstN(st.cashIncomes, 200));

  renderTable($("#tblWh"), [
    { label:"Дата", value:(r)=>r.date },
    { label:"Валюта", value:(r)=>r.currency },
    { label:"Сума", value:(r)=>r.amount, num:true },
    { label:"Опис", value:(r)=>r.description },
  ], firstN(st.withholdings, 200));

  renderTable($("#tblPos"), [
    { label:"Актив", value:(r)=>r.asset.symbolRaw },
    { label:"assetKey", value:(r)=>r.asset.assetKey },
    { label:"К-ть", value:(r)=>r.quantity, num:true },
    { label:"Валюта", value:(r)=>r.asset.currency },
    { label:"Вартість", value:(r)=>r.value, num:true },
    { label:"Нереаліз. P/L", value:(r)=>r.unrealizedPL, num:true },
  ], firstN(st.positions, 200));
}

/* =========================
   Results render
========================= */
function renderResults(f1, taxSummary) {
  const lines = [];
  lines.push("ІНВЕСТ‑РЕЗУЛЬТАТ (FIFO, грн)");
  lines.push(`• Дохід: ${fmt2(taxSummary.invest.incomeUAH)}`);
  lines.push(`• Витрати: ${fmt2(taxSummary.invest.costUAH)}`);
  lines.push(`• Фінрезультат: ${fmt2(taxSummary.invest.resultUAH)}`);
  lines.push(`• Перенесений збиток: ${fmt2(taxSummary.invest.carryLossUAH)}`);
  lines.push(`• Підсумок (ряд.3): ${fmt2(taxSummary.invest.netResultUAH)}`);
  lines.push(`• Прибуток (ряд.3.1): ${fmt2(taxSummary.invest.netProfitUAH)}`);
  lines.push(`• ПДФО (інвест): ${fmt2(taxSummary.invest.pitUAH)}`);
  lines.push(`• ВЗ (інвест): ${fmt2(taxSummary.invest.milUAH)}`);
  lines.push(`• FIFO‑операцій (за рік): ${String(f1.operations.length)}`);
  lines.push("");
  lines.push("ДИВІДЕНДИ (грн)");
  lines.push(`• Дивіденди: ${fmt2(taxSummary.dividends.dividendsUAH)}`);
  lines.push(`• Утримано (div): ${fmt2(taxSummary.dividends.withholdingDivUAH)}`);
  lines.push(`• ПДФО (gross): ${fmt2(taxSummary.dividends.pitGrossUAH)}`);
  lines.push(`• Залік: ${fmt2(taxSummary.dividends.creditUAH)}`);
  lines.push(`• ПДФО до сплати: ${fmt2(taxSummary.dividends.pitDueUAH)}`);
  lines.push(`• ВЗ до сплати: ${fmt2(taxSummary.dividends.milUAH)}`);
  lines.push("");
  lines.push("РАЗОМ");
  lines.push(`• ПДФО всього: ${fmt2(taxSummary.totals.pitUAH)}`);
  lines.push(`• ВЗ всього: ${fmt2(taxSummary.totals.milUAH)}`);
  lines.push(`• Всього до сплати: ${fmt2(taxSummary.totals.totalUAH)}`);

  setStatus($("#resultsBox"), lines.join("\n"), "good");

  renderTable($("#tblF1"), [
    { label:"№", value:(r)=>r.n },
    { label:"Код", value:(r)=>r.assetType },
    { label:"Найменування", value:(r)=>r.name },
    { label:"Дохід (грн)", value:(r)=>r.incomeUAH, num:true },
    { label:"Витрати (грн)", value:(r)=>r.costUAH, num:true },
    { label:"Результат (грн)", value:(r)=>r.resultUAH, num:true },
    { label:"assetKey", value:(r)=>r.assetKey },
  ], f1.rows.slice().sort((a,b)=>a.name.localeCompare(b.name)));

  renderTable($("#tblOps"), [
    { label:"Дата закриття", value:(r)=>r.closeDate },
    { label:"assetKey", value:(r)=>r.assetKey },
    { label:"К-ть (abs)", value:(r)=>r.qtyAbs, num:true },
    { label:"Дохід (грн)", value:(r)=>r.incomeUAH, num:true },
    { label:"Витрати (грн)", value:(r)=>r.costUAH, num:true },
    { label:"Результат (грн)", value:(r)=>r.resultUAH, num:true },
  ], firstN(f1.operations, 300));
}

/* =========================
   UI wiring
========================= */
$("#f1AssetTypeMode").addEventListener("change", () => {
  $("#manualMapWrap").style.display = ($("#f1AssetTypeMode").value === "MANUAL") ? "block" : "none";
});
$("#taxYear").addEventListener("change", () => {
  updateFxUi();
  updateReadinessUi();
});

$("#fileCsv").addEventListener("change", () => {
  $("#btnParse").disabled = !$("#fileCsv").files || $("#fileCsv").files.length === 0;
  $("#btnReset").disabled = $("#btnParse").disabled;
  setStatus($("#statusUpload"), $("#btnParse").disabled ? "Очікую CSV…" : `Файл обрано: ${$("#fileCsv").files[0].name}\nНатисніть “Розпізнати звіт”.`);
});

$("#btnReset").addEventListener("click", () => {
  state.statement = null;
  state.assetIndex = null;
  state.fifo = null;
  state.f1 = null;
  state.taxSummary = null;
  state.fxNeeds = null;

  fxClear();

  $("#fileCsv").value = "";
  $("#fxFiles").value = "";

  $("#btnParse").disabled = true;
  $("#btnReset").disabled = true;

  $("#btnCalc").disabled = true;
  $("#btnShowLosers").disabled = true;

  $("#btnDownloadParsed").disabled = true;

  $("#btnExportXlsx").disabled = true;
  $("#btnExportCsv").disabled = true;
  $("#btnPrintF1").disabled = true;
  $("#btnDownloadDebug").disabled = true;

  $("#btnDownloadFx").disabled = true;
  $("#btnShowFxLinks").disabled = true;
  $("#btnDownloadFxLinksFile").disabled = true;
  $("#btnClearFx").disabled = true;

  $("#fxLinksBox").style.display = "none";
  $("#fxLinksBox").innerHTML = "";

  $("#kpiDates").textContent = "—";
  $("#kpiCurrencies").textContent = "—";
  $("#kpiTrades").textContent = "—";
  $("#kpiOther").textContent = "—";
  $("#warningsBox").style.display = "none";

  $("#tblTrades").innerHTML = "";
  $("#tblDiv").innerHTML = "";
  $("#tblWh").innerHTML = "";
  $("#tblPos").innerHTML = "";
  $("#tblF1").innerHTML = "";
  $("#tblOps").innerHTML = "";

  setStatus($("#statusUpload"), "Очікую CSV…");
  setStatus($("#fxStatus"), "Спочатку розпізнайте CSV, щоб визначити потрібні валюти та дати.");
  setStatus($("#statusCalc"), "Спочатку розпізнайте CSV та підготуйте курси НБУ.");
  setStatus($("#resultsBox"), "Поки що немає розрахунку.");
  setStatus($("#losersBox"), "Поки що немає даних.");
});

$("#btnParse").addEventListener("click", async () => {
  try {
    $("#btnParse").disabled = true;
    const f = $("#fileCsv").files[0];

    setStatus($("#statusUpload"), "Читаю файл…");
    const text = await f.text();

    setStatus($("#statusUpload"), "Обробляю CSV…");
    const rows = parseCSV(text);

    setStatus($("#statusUpload"), "Розпізнаю секції…");
    const st = parseFlexReport(rows, f.name);

    state.statement = st;
    state.assetIndex = buildAssetIndex(st);

    renderPreview(st);

    $("#btnDownloadParsed").disabled = false;
    $("#btnReset").disabled = false;

    setStatus($("#statusUpload"),
      `Готово ✅\n` +
      `Угоди (Trades): ${st.trades.length}\n` +
      `Дивіденди: ${st.cashIncomes.length}\n` +
      `Утримання податку: ${st.withholdings.length}\n` +
      `Відкриті позиції: ${st.positions.length}`,
      "good"
    );

    updateFxUi();
    updateReadinessUi();
  } catch (e) {
    console.error(e);
    setStatus($("#statusUpload"), "Помилка розпізнавання:\n" + (e?.message || String(e)), "bad");
  } finally {
    $("#btnParse").disabled = false;
  }
});

$("#btnDownloadParsed").addEventListener("click", () => {
  if (!state.statement) return;
  downloadBlob(`statement_${state.statement.meta.fileName}.json`, "application/json;charset=utf-8", JSON.stringify(state.statement, null, 2));
});

$("#btnShowFxLinks").addEventListener("click", () => {
  if (!state.statement) return;
  const needs = state.fxNeeds || computeFxNeeds(state.statement, readSettings().taxYear);
  $("#fxLinksBox").style.display = "block";
  $("#fxLinksBox").innerHTML = buildFxLinksHtml(needs);
});

$("#btnDownloadFxLinksFile").addEventListener("click", () => {
  if (!state.statement) return;
  const needs = state.fxNeeds || computeFxNeeds(state.statement, readSettings().taxYear);
  downloadFxLinksFile(needs);
});

$("#btnClearFx").addEventListener("click", () => {
  fxClear();
  updateFxUi();
  updateReadinessUi();
  setStatus($("#fxStatus"), $("#fxStatus").textContent + "\n\nКурси очищено.", "warn");
});

$("#btnLoadFxFiles").addEventListener("click", async () => {
  try {
    const files = $("#fxFiles").files;
    if (!files || !files.length) {
      setStatus($("#fxStatus"), "Оберіть JSON‑файли курсів, потім натисніть “Підвантаж JSON‑файли”.", "warn");
      return;
    }
    setStatus($("#fxStatus"), "Завантажую JSON‑файли курсів…");
    await loadFxFromFiles(files, (msg)=>setStatus($("#fxStatus"), msg));
    fxStore.meta.provider = fxStore.meta.provider || "NBU_FILES";
    fxStore.meta.currencies = fxCurrenciesLoaded();

    updateFxUi();
    updateReadinessUi();
    setStatus($("#fxStatus"), $("#fxStatus").textContent + "\n\nКурси завантажено ✅", "good");
  } catch (e) {
    console.error(e);
    setStatus($("#fxStatus"), "Помилка завантаження курсів:\n" + (e?.message || String(e)), "bad");
  }
});

$("#btnDownloadFx").addEventListener("click", async () => {
  if (!state.statement) return;
  const needs = state.fxNeeds || computeFxNeeds(state.statement, readSettings().taxYear);

  try {
    setStatus($("#fxStatus"), "Готую завантаження…");
    const bundle = await downloadNbuFxBundleOnline(needs, (msg)=>setStatus($("#fxStatus"), msg));

    loadFxFromBundle(bundle);
    fxStore.meta.provider = "NBU_ONLINE";
    fxStore.meta.range = { start: needs.startIso, end: needs.endIso };
    fxStore.meta.currencies = fxCurrenciesLoaded();
    fxStore.meta.loadedAt = new Date().toISOString();

    const fileName = `nbu_fx_${needs.startIso}_${needs.endIso}.json`;
    downloadBlob(fileName, "application/json;charset=utf-8", JSON.stringify(bundle, null, 2));

    updateFxUi();
    updateReadinessUi();
    setStatus($("#fxStatus"), $("#fxStatus").textContent + `\n\nГотово ✅ Файл збережено: ${fileName}`, "good");
  } catch (e) {
    console.error(e);
    setStatus($("#fxStatus"), (e?.message || String(e)), "bad");
    $("#fxLinksBox").style.display = "block";
    $("#fxLinksBox").innerHTML = buildFxLinksHtml(needs);
  }
});

$("#btnCalc").addEventListener("click", async () => {
  if (!state.statement) return;

  try {
    $("#btnCalc").disabled = true;
    $("#btnExportXlsx").disabled = true;
    $("#btnExportCsv").disabled = true;
    $("#btnPrintF1").disabled = true;
    $("#btnDownloadDebug").disabled = true;

    const settings = readSettings();

    setStatus($("#statusCalc"), "Перевіряю курси…");
    assertFxCoverage(state.statement, settings.taxYear);

    setStatus($("#statusCalc"), "Розраховую FIFO (інвест‑результат)…");
    const fifo = await fifoInUAH(state.statement.trades);
    state.fifo = fifo;

    setStatus($("#statusCalc"), "Розраховую дивіденди та утриманий податок…");
    const div = await computeDividendsUAH(state.statement, settings);
    const whDiv = await computeWithholdingOnDivUAH(state.statement, settings);

    setStatus($("#statusCalc"), "Формую Ф1…");
    const f1 = buildF1Model(state.statement, state.assetIndex, fifo.matches, settings);
    state.f1 = f1;

    const divUAH = round2(div.totalUAH);
    const whDivUAH = round2(whDiv.totalUAH);

    const divPITgross = round2(divUAH * settings.pitDivRate);
    const divMIL = round2(divUAH * settings.milDivRate);
    const credit = settings.useForeignTaxCredit ? Math.min(divPITgross, whDivUAH) : 0;
    const divPITdue = round2(divPITgross - credit);

    const totalPIT = round2(f1.investTaxes.pitDueUAH + divPITdue);
    const totalMIL = round2(f1.investTaxes.milDueUAH + divMIL);

    const taxSummary = {
      invest: {
        incomeUAH: f1.totals.totalIncomeUAH,
        costUAH: f1.totals.totalCostUAH,
        resultUAH: f1.totals.totalResultUAH,
        carryLossUAH: f1.totals.carryLossUAH,
        netResultUAH: f1.totals.netResultUAH,
        netProfitUAH: f1.totals.netProfitUAH,
        pitUAH: f1.investTaxes.pitDueUAH,
        milUAH: f1.investTaxes.milDueUAH,
      },
      dividends: {
        dividendsUAH: divUAH,
        withholdingDivUAH: whDivUAH,
        pitGrossUAH: divPITgross,
        creditUAH: round2(credit),
        pitDueUAH: divPITdue,
        milUAH: divMIL
      },
      totals: {
        pitUAH: totalPIT,
        milUAH: totalMIL,
        totalUAH: round2(totalPIT + totalMIL),
      }
    };
    state.taxSummary = taxSummary;

    renderResults(f1, taxSummary);

    $("#btnExportXlsx").disabled = false;
    $("#btnExportCsv").disabled = false;
    $("#btnPrintF1").disabled = false;
    $("#btnDownloadDebug").disabled = false;
    $("#btnShowLosers").disabled = false;

    setStatus($("#statusCalc"), "Готово ✅", "good");
  } catch (e) {
    console.error(e);
    setStatus($("#statusCalc"), "Помилка розрахунку:\n" + (e?.message || String(e)), "bad");
  } finally {
    $("#btnCalc").disabled = false;
  }
});

$("#btnExportCsv").addEventListener("click", () => {
  if (!state.f1) return;
  exportCsvF1AndOps(state.f1);
});
$("#btnPrintF1").addEventListener("click", () => {
  if (!state.f1) return;
  exportPrintableF1(state.f1);
});
$("#btnExportXlsx").addEventListener("click", async () => {
  if (!state.statement || !state.f1 || !state.taxSummary) return;
  await exportXlsx(state.statement, state.f1, state.taxSummary, readSettings());
});
$("#btnDownloadDebug").addEventListener("click", () => {
  if (!state.statement) return;
  const obj = {
    statement: state.statement,
    fxMeta: fxStore.meta,
    computed: {
      fifo: state.fifo,
      f1: state.f1,
      taxSummary: state.taxSummary
    }
  };
  downloadBlob(`debug_${state.statement.meta.fileName}.json`, "application/json;charset=utf-8", JSON.stringify(obj, null, 2));
});

$("#btnShowLosers").addEventListener("click", async () => {
  if (!state.statement || !state.taxSummary) return;
  try {
    const asOf = ($("#asOfDate").value || "").trim();
    const topN = Number($("#topN").value || 15);

    const pitRate = Number($("#pitInvestRate").value);
    const milRate = Number($("#milInvestRate").value);
    const netProfit = state.taxSummary.invest.netProfitUAH;

    setStatus($("#losersBox"), "Розраховую…");
    const rows = await computeTopLosers(state.statement, asOf, topN, netProfit, pitRate, milRate);

    const cols = [
      { label:"Актив", value:(r)=>r.p.asset.symbolRaw },
      { label:"К-ть", value:(r)=>r.p.quantity, num:true },
      { label:"Валюта", value:(r)=>r.p.asset.currency },
      { label:"Нереаліз. (грн)", value:(r)=>r.unrealizedUAH, num:true },
      { label:"Збиток (грн)", value:(r)=>r.lossUAH, num:true },
      { label:"Оцінка економії податку", value:(r)=>r.estTaxSaved, num:true },
    ];

    const box = $("#losersBox");
    box.innerHTML = "";

    const info = document.createElement("div");
    info.className = "small muted";
    info.style.whiteSpace = "pre-wrap";
    info.textContent = `Дата FX: ${asOf}\nПоточний інвест‑прибуток (для оцінки економії): ${fmt2(netProfit)} грн\n`;
    box.appendChild(info);

    const wrap = document.createElement("div");
    wrap.className = "tableWrap";
    const table = document.createElement("table");
    renderTable(table, cols, rows);
    wrap.appendChild(table);
    box.appendChild(wrap);
  } catch (e) {
    console.error(e);
    setStatus($("#losersBox"), "Помилка:\n" + (e?.message || String(e)), "bad");
  }
});

/* =========================
   Init
========================= */
setStatus($("#statusUpload"), "Очікую CSV…");
setStatus($("#fxStatus"), "Спочатку розпізнайте CSV, щоб визначити потрібні валюти та дати.");
setStatus($("#statusCalc"), "Спочатку розпізнайте CSV та підготуйте курси НБУ.");
</script>
</body>
</html>
